#!/bin/bash
# GSD Ralph - Learnings Propagation
# Part of Phase 7: Learnings Propagation
#
# Provides AGENTS.md management functions for learning extraction, storage,
# and retrieval. Learnings are project-specific patterns discovered during
# autonomous execution that improve future iterations.
#
# Functions: init_agents_file, get_learnings_for_phase, append_learning,
#            extract_learnings_from_summary, prune_agents_if_needed
#
# Usage:
#   source bin/lib/learnings.sh
#   init_agents_file
#   append_learning "Error Fixes" "When permission denied on shell scripts, run chmod +x bin/*.sh"
#   get_learnings_for_phase 7

# Configuration
AGENTS_FILE="${AGENTS_FILE:-.planning/AGENTS.md}"
MAX_AGENTS_LINES=100
MAX_AGENTS_LINES_HARD=150

# Color codes (respect NO_COLOR standard)
if [[ -n "${NO_COLOR:-}" ]]; then
    LEARN_RED=''
    LEARN_YELLOW=''
    LEARN_RESET=''
else
    LEARN_RED='\e[31m'
    LEARN_YELLOW='\e[33m'
    LEARN_RESET='\e[0m'
fi

# =============================================================================
# Initialization Functions
# =============================================================================

# init_agents_file - Create AGENTS.md with initial structure
# Returns: 0 on success, 1 on failure
# Creates .planning directory if needed, uses atomic write pattern
init_agents_file() {
    # Ensure directory exists
    local agents_dir
    agents_dir=$(dirname "$AGENTS_FILE")
    if [[ ! -d "$agents_dir" ]]; then
        mkdir -p "$agents_dir"
    fi

    # Create initial structure
    local content
    content='# Project Learnings

Project-specific patterns discovered during autonomous execution.
Auto-generated by ralph.sh - manual edits preserved.

## Error Fixes

When you encounter specific errors, apply these fixes:

## Codebase Patterns

Project conventions discovered during execution:

## Phase-Specific

'
    # Write to temp then mv for atomicity
    local temp="${AGENTS_FILE}.tmp.$$"
    printf '%s' "$content" > "$temp"

    if [[ $? -ne 0 ]]; then
        echo -e "${LEARN_RED}Error: Failed to write temp file${LEARN_RESET}" >&2
        rm -f "$temp" 2>/dev/null
        return 1
    fi

    mv "$temp" "$AGENTS_FILE"
    return $?
}

# =============================================================================
# Section Loading Functions
# =============================================================================

# get_learnings_for_phase - Extract relevant sections from AGENTS.md
# Args: phase_num - The phase number to load learnings for
# Output: Concatenated relevant learnings to stdout
# Returns: 0 always (missing file is OK - no learnings yet)
#
# Loads: "Error Fixes" (always), "Codebase Patterns" (always),
#        "Phase {N}" subsection under Phase-Specific if exists
get_learnings_for_phase() {
    local phase_num="$1"

    if [[ ! -f "$AGENTS_FILE" ]]; then
        return 0  # No learnings yet, OK
    fi

    # Extract "Error Fixes" section content (between ## Error Fixes and next ##)
    local error_fixes
    error_fixes=$(sed -n '/^## Error Fixes/,/^## /{
        /^## Error Fixes/d
        /^## /d
        p
    }' "$AGENTS_FILE")

    # Extract "Codebase Patterns" section content
    local codebase_patterns
    codebase_patterns=$(sed -n '/^## Codebase Patterns/,/^## /{
        /^## Codebase Patterns/d
        /^## /d
        p
    }' "$AGENTS_FILE")

    # Extract phase-specific subsection (### Phase N:)
    local phase_specific
    if [[ -n "$phase_num" ]]; then
        phase_specific=$(sed -n "/^### Phase ${phase_num}:/,/^### /{
            /^### Phase ${phase_num}:/d
            /^### /d
            p
        }" "$AGENTS_FILE")
    fi

    # Output combined learnings
    local output=""

    # Add error fixes if any
    if [[ -n "$error_fixes" && -n "$(echo "$error_fixes" | tr -d '[:space:]')" ]]; then
        output+="Error Fixes:"
        output+=$'\n'
        output+="$error_fixes"
    fi

    # Add codebase patterns if any
    if [[ -n "$codebase_patterns" && -n "$(echo "$codebase_patterns" | tr -d '[:space:]')" ]]; then
        if [[ -n "$output" ]]; then
            output+=$'\n'
        fi
        output+="Codebase Patterns:"
        output+=$'\n'
        output+="$codebase_patterns"
    fi

    # Add phase-specific if any
    if [[ -n "$phase_specific" && -n "$(echo "$phase_specific" | tr -d '[:space:]')" ]]; then
        if [[ -n "$output" ]]; then
            output+=$'\n'
        fi
        output+="Phase ${phase_num} specific:"
        output+=$'\n'
        output+="$phase_specific"
    fi

    echo "$output"
    return 0
}

# =============================================================================
# Learning Storage Functions
# =============================================================================

# append_learning - Add learning if not already present
# Args: section - Target section name (e.g., "Error Fixes", "Codebase Patterns", "Phase 5")
#       learning - The learning text to add (will be prefixed with "- ")
# Returns: 0 on success (including if already exists - idempotent)
#
# Deduplication: Uses grep -qF for exact match check
# For "Phase N" sections, creates as ### subsection under ## Phase-Specific
append_learning() {
    local section="$1"
    local learning="$2"

    if [[ -z "$section" || -z "$learning" ]]; then
        echo -e "${LEARN_RED}Error: append_learning requires section and learning${LEARN_RESET}" >&2
        return 1
    fi

    # Ensure AGENTS.md exists
    if [[ ! -f "$AGENTS_FILE" ]]; then
        init_agents_file
    fi

    # Check if learning already exists (exact match deduplication)
    if grep -qF "$learning" "$AGENTS_FILE" 2>/dev/null; then
        return 0  # Already exists, silently skip (idempotent)
    fi

    # Determine if this is a phase-specific section (Phase N)
    local is_phase_section=false
    local phase_num=""
    if [[ "$section" =~ ^Phase\ ([0-9]+)$ ]]; then
        is_phase_section=true
        phase_num="${BASH_REMATCH[1]}"
    fi

    # Create temp file for atomic write
    local temp
    temp=$(mktemp)

    if [[ "$is_phase_section" == "true" ]]; then
        # Phase-specific: Add under ## Phase-Specific as ### Phase N: subsection
        local subsection_header="### Phase ${phase_num}:"

        # Check if subsection exists
        if grep -q "^${subsection_header}$" "$AGENTS_FILE" 2>/dev/null; then
            # Subsection exists - insert after header
            awk -v header="$subsection_header" -v learning="- $learning" '
                $0 == header {
                    print
                    getline
                    print
                    print learning
                    next
                }
                { print }
            ' "$AGENTS_FILE" > "$temp"
        else
            # Subsection doesn't exist - create it under Phase-Specific
            awk -v header="$subsection_header" -v learning="- $learning" '
                /^## Phase-Specific/ {
                    print
                    getline
                    print
                    print header
                    print ""
                    print learning
                    print ""
                    next
                }
                { print }
            ' "$AGENTS_FILE" > "$temp"
        fi
    else
        # Regular section (Error Fixes, Codebase Patterns)
        local section_header="## $section"

        # Check if section exists
        if grep -q "^${section_header}$" "$AGENTS_FILE" 2>/dev/null; then
            # Section exists - insert after intro text (header + intro line + blank)
            # Pattern: ## Header\n\nIntro text:\n\n<learnings go here>
            awk -v header="$section_header" -v learning="- $learning" '
                BEGIN { found_header = 0; blank_count = 0; added = 0 }
                $0 == header {
                    found_header = 1
                    print
                    next
                }
                found_header && !added {
                    if (/^$/) {
                        blank_count++
                        print
                        # After second blank line (after intro text), insert learning
                        if (blank_count == 2) {
                            print learning
                            added = 1
                            found_header = 0
                        }
                        next
                    }
                    # If we hit a list item before second blank, insert before it
                    if (/^- /) {
                        print learning
                        added = 1
                        found_header = 0
                    }
                    # Print the current line
                    print
                    next
                }
                { print }
            ' "$AGENTS_FILE" > "$temp"
        else
            # Section doesn't exist - create it at end of file
            cp "$AGENTS_FILE" "$temp"
            {
                echo ""
                echo "$section_header"
                echo ""
                echo "- $learning"
                echo ""
            } >> "$temp"
        fi
    fi

    # Atomic replace
    mv "$temp" "$AGENTS_FILE"
    return $?
}
