---
phase: 02-state-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/STATE.md
  - bin/lib/state.sh
autonomous: true
user_setup: []

must_haves:
  truths:
    - "STATE.md has structured sections with HTML comment markers"
    - "Fresh Claude instance can parse STATE.md and extract current phase, plan, and status"
    - "Next Action section shows command-ready instruction for resumption"
    - "Iteration History section exists with table format"
  artifacts:
    - path: "bin/lib/state.sh"
      provides: "STATE.md manipulation functions"
      exports: ["update_current_position", "update_next_action", "add_iteration_entry", "atomic_write"]
      min_lines: 80
    - path: ".planning/STATE.md"
      provides: "Extended state file with lazy mode sections"
      contains: ["<!-- HISTORY_START -->", "<!-- HISTORY_END -->", "## Next Action", "## Iteration History"]
  key_links:
    - from: "bin/lib/state.sh"
      to: ".planning/STATE.md"
      via: "atomic file writes with markers"
      pattern: "atomic_write.*STATE"
---

<objective>
Create STATE.md schema extensions and bash library functions for programmatic state updates.

Purpose: Enable the outer loop (Phase 3) to track iteration state, persist outcomes, and provide clear resumption instructions for fresh Claude instances.

Output: Extended STATE.md structure with HTML comment markers and state.sh library with update functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-state-extensions/02-CONTEXT.md
@.planning/phases/02-state-extensions/02-RESEARCH.md

# Reference Phase 1 libraries for patterns
@bin/lib/budget.sh
@bin/lib/display.sh
@bin/lib/failfast.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend STATE.md with lazy mode sections</name>
  <files>.planning/STATE.md</files>
  <action>
Add the following sections to STATE.md, preserving existing content:

1. Add "## Next Action" section after "## Current Position" with:
   - Command: (e.g., `/gsd:execute-phase 2`)
   - Description: (e.g., `Execute plan 02-01 (STATE.md schema extensions)`)
   - Read: (e.g., `ROADMAP.md, 02-01-PLAN.md`)

2. Add "## Iteration History" section with HTML comment markers:
   ```
   ## Iteration History
   <!-- HISTORY_START -->
   | # | Timestamp | Outcome | Task |
   |---|-----------|---------|------|
   <!-- HISTORY_END -->
   ```

3. Update "## Current Position" section to include progress bar:
   - Add `Progress: [##                            ] 7%` line (represents 2/26 plans complete)
   - Preserve existing Phase, Plan, Status, Last activity lines

4. Ensure sections are ordered: Current Position -> Next Action -> Iteration History -> (existing sections)

Use markers that are unique and will not appear elsewhere in the file.
  </action>
  <verify>
Verify STATE.md has the new sections:
- `grep "## Next Action" .planning/STATE.md` returns match
- `grep "HISTORY_START" .planning/STATE.md` returns match
- `grep "Progress:" .planning/STATE.md` returns match
  </verify>
  <done>
STATE.md contains Next Action, Iteration History (with markers), and Progress line in Current Position section.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create state.sh library with update functions</name>
  <files>bin/lib/state.sh</files>
  <action>
Create `bin/lib/state.sh` following the pattern established by budget.sh, display.sh, and failfast.sh.

Include these functions:

1. `atomic_write target content` - Write content to temp file, then mv to target (crash-safe)

2. `update_section file start_marker end_marker new_content` - Replace content between markers using awk, with atomic write

3. `update_current_position phase_num plan_num phase_name status` - Update the Current Position section:
   - Updates Phase, Plan, Status lines
   - Updates Last activity timestamp (format: YYYY-MM-DD HH:MM:SS)
   - Does NOT update Progress (separate function)

4. `update_next_action phase_num plan_id plan_name [last_failure_note]` - Update Next Action section:
   - Sets Command: /gsd:execute-phase {phase_num}
   - Sets Description: Execute plan {plan_id} ({plan_name})
   - Sets Read: ROADMAP.md, {plan_id}-PLAN.md
   - If last_failure_note provided, adds **Note:** line

5. `add_iteration_entry iteration_num outcome task_name` - Add entry to Iteration History:
   - Format: | {iteration} | {timestamp} | {outcome} | {task_name} |
   - Timestamp: YYYY-MM-DD HH:MM:SS format
   - Prepend new entry (newest first), keeping table header
   - Outcomes: SUCCESS, FAILURE, RETRY, SKIPPED

6. `get_iteration_count` - Parse history and return count of entries

Configuration at top of file:
```bash
STATE_FILE="${STATE_FILE:-.planning/STATE.md}"
```

Follow Phase 1 patterns:
- Add shebang and documentation header
- Use ANSI colors for any error messages (RED for errors)
- Functions return 0 on success, 1 on failure
- Use [[ ]] for conditionals
  </action>
  <verify>
Source the library and test functions exist:
```bash
source bin/lib/state.sh && type atomic_write && type update_section && type update_current_position && type update_next_action && type add_iteration_entry && type get_iteration_count
```
  </verify>
  <done>
state.sh exists with 6 documented functions that can be sourced by ralph.sh.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify state.sh functions work with STATE.md</name>
  <files>bin/lib/state.sh, .planning/STATE.md</files>
  <action>
Create a test that verifies the integration:

1. Source state.sh
2. Call add_iteration_entry with test data: `add_iteration_entry 1 "SUCCESS" "02-01: STATE.md schema extensions"`
3. Verify the entry appears in STATE.md Iteration History section
4. Call update_next_action: `update_next_action 2 "02-02" "Progress indicator implementation"`
5. Verify Next Action section updated
6. Remove test entry from STATE.md (restore to clean state)

If any function fails, fix it before proceeding. The functions must work correctly because Phase 3 will depend on them.

Test edge cases:
- Empty history (first entry)
- Timestamp format is correct
- Markers preserved after update
  </action>
  <verify>
Run integration test:
```bash
source bin/lib/state.sh && \
  add_iteration_entry 1 "SUCCESS" "test-task" && \
  grep "test-task" .planning/STATE.md && \
  echo "Integration verified"
```
Then manually clean up test entry from STATE.md.
  </verify>
  <done>
state.sh functions correctly update STATE.md sections. Integration verified and test data cleaned up.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. STATE.md has all required sections with correct markers
2. state.sh can be sourced without errors
3. All 6 functions are defined and callable
4. Functions correctly manipulate STATE.md (entries appear, sections update)
5. Atomic write pattern prevents corruption (write to temp, mv to target)
</verification>

<success_criteria>
- [ ] STATE.md contains Next Action section with Command, Description, Read fields
- [ ] STATE.md contains Iteration History section with HISTORY_START/HISTORY_END markers
- [ ] STATE.md Current Position section has Progress line
- [ ] bin/lib/state.sh exists with 6 functions
- [ ] Functions use atomic write pattern (mktemp + mv)
- [ ] Integration test passes (can add entry, can update next action)
- [ ] All changes committed to git
</success_criteria>

<output>
After completion, create `.planning/phases/02-state-extensions/02-01-SUMMARY.md`
</output>
