---
phase: 01-safety-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/failfast.sh
autonomous: true

must_haves:
  truths:
    - "Failed Claude invocation retries up to 3 times before giving up"
    - "After 3 failed retries, execution stops entirely (doesn't try next task)"
    - "Rollback discards partial work and resets to last checkpoint"
    - "Exit codes from Claude CLI determine success/failure"
    - "Errors surface immediately with clear message"
  artifacts:
    - path: "bin/lib/failfast.sh"
      provides: "Retry logic and rollback functions"
      exports: ["run_with_retry", "mark_checkpoint", "rollback_to_checkpoint", "check_limits"]
  key_links:
    - from: "bin/lib/failfast.sh"
      to: "claude CLI"
      via: "exit code check"
      pattern: "\\$\\?"
    - from: "bin/lib/failfast.sh"
      to: "git"
      via: "reset --hard"
      pattern: "git reset --hard"
---

<objective>
Create fail-fast error handling patterns for ralph loop

Purpose: Implement retry logic that gives tasks 3 attempts before failing, then stops entirely rather than burning tokens on subsequent tasks. Includes git checkpoint/rollback for clean recovery when limits are hit.

Output: Bash library file (failfast.sh) that ralph.sh will source in Phase 3.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-safety-foundation/01-CONTEXT.md
@.planning/phases/01-safety-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retry wrapper function</name>
  <files>bin/lib/failfast.sh</files>
  <action>
Create bin/lib/failfast.sh with the retry function:

1. `run_with_retry()` - Execute command with retry logic
   - Args: command to run (as string or function name), task_name
   - MAX_RETRIES=3 (hardcoded per user decision)
   - Loop up to MAX_RETRIES attempts
   - Execute command, capture exit code with $?
   - On success (exit code 0): return 0
   - On failure: log attempt number, sleep 5 seconds, retry
   - After all retries exhausted: return 1 with clear error message
   - Output format: "  Attempt N/3 for: task_name"

2. `run_claude_task()` - Wrapper specifically for Claude CLI
   - Args: prompt, output_file (optional, defaults to temp file)
   - Run: claude -p "$prompt" --output-format json > "$output_file" 2>&1
   - Return Claude's exit code
   - Clean up temp file on success

Use colors from display.sh (source it or define locally).
GREEN for success, RED for failure, YELLOW for retry.

Key behavior: This function does NOT decide what to do after failure - it just returns 1.
The caller (ralph.sh) will handle rollback and exit.
  </action>
  <verify>
```bash
source bin/lib/failfast.sh

# Test with always-failing command
run_with_retry "false" "test-fail" && echo "UNEXPECTED" || echo "PASS: failed after retries"

# Test with always-succeeding command
run_with_retry "true" "test-success" && echo "PASS: succeeded" || echo "UNEXPECTED"
```
  </verify>
  <done>
- run_with_retry retries 3 times on failure
- run_with_retry returns 0 on first success
- run_with_retry returns 1 after 3 failures
- Attempt numbers logged correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create checkpoint and rollback functions</name>
  <files>bin/lib/failfast.sh</files>
  <action>
Add to bin/lib/failfast.sh:

1. `mark_checkpoint()` - Record current git HEAD as checkpoint
   - Store commit SHA in CHECKPOINT_COMMIT global variable
   - Log: "Checkpoint: {short-sha}"
   - Return 1 if not in a git repo

2. `rollback_to_checkpoint()` - Reset to last checkpoint
   - Check if CHECKPOINT_COMMIT is set
   - Run: git reset --hard "$CHECKPOINT_COMMIT"
   - Log: "Rolled back to checkpoint: {short-sha}"
   - Log: "Partial work discarded"
   - Return 1 if no checkpoint set

3. `check_limits()` - Check if iteration or timeout limit reached
   - Args: current_iteration
   - Requires globals: MAX_ITERATIONS, TIMEOUT_HOURS, START_TIME
   - Check: current_iteration >= MAX_ITERATIONS
   - Check: elapsed >= (TIMEOUT_HOURS * 3600)
   - Return 0 if within limits, 1 if limit reached
   - Set LIMIT_REASON global ("iteration" or "timeout")

Handle edge cases:
- Not in a git repo (mark_checkpoint should warn)
- No checkpoint set when rollback called
- START_TIME not set when check_limits called (use current time as start)
  </action>
  <verify>
```bash
source bin/lib/failfast.sh

# Test checkpoint (requires git repo)
cd /tmp && git init test-repo && cd test-repo
echo "test" > file.txt && git add . && git commit -m "initial"
mark_checkpoint
echo "changed" > file.txt
cat file.txt  # Should show "changed"
rollback_to_checkpoint
cat file.txt  # Should show "test"
cd .. && rm -rf test-repo
```
  </verify>
  <done>
- mark_checkpoint stores current HEAD
- rollback_to_checkpoint resets to stored checkpoint
- Partial changes are discarded on rollback
- check_limits returns 1 when either limit exceeded
  </done>
</task>

<task type="auto">
  <name>Task 3: Add fail-stop behavior and integration points</name>
  <files>bin/lib/failfast.sh</files>
  <action>
Add to bin/lib/failfast.sh:

1. `handle_task_failure()` - Called when task fails after retries
   - Args: task_name
   - Log clear error: "FATAL: Task '$task_name' failed after 3 attempts"
   - Log: "Stopping execution to prevent further token burn"
   - Call rollback_to_checkpoint
   - Return 1 (caller should exit)

2. `handle_limit_reached()` - Called when budget exhausted
   - Args: none (reads LIMIT_REASON global)
   - Log: "LIMIT REACHED: {iteration/timeout}"
   - Call rollback_to_checkpoint
   - Return 1 (caller should exit)

Add header and shebang:
```bash
#!/bin/bash
# GSD Ralph - Fail-Fast Error Handling
# Part of Phase 1: Safety Foundation
#
# Provides:
#   run_with_retry    - Retry command up to 3 times
#   run_claude_task   - Execute Claude CLI with error handling
#   mark_checkpoint   - Record git HEAD as rollback point
#   rollback_to_checkpoint - Reset to last checkpoint
#   check_limits      - Verify iteration/timeout within budget
#   handle_task_failure - Process task failure with rollback
#   handle_limit_reached - Process budget exhaustion with rollback
```

Define colors at top (same as display.sh for consistency):
```bash
RED='\e[31m'
GREEN='\e[32m'
YELLOW='\e[33m'
BOLD='\e[1m'
RESET='\e[0m'
```
  </action>
  <verify>
```bash
source bin/lib/failfast.sh

# Verify all functions exist
type run_with_retry mark_checkpoint rollback_to_checkpoint
type check_limits handle_task_failure handle_limit_reached

# Test handle functions output
MAX_ITERATIONS=5
TIMEOUT_HOURS=1
START_TIME=$(date +%s)
check_limits 3 && echo "PASS: within limits" || echo "FAIL"
check_limits 5 && echo "FAIL: should exceed" || echo "PASS: limit reached"
```
  </verify>
  <done>
- All 7 functions defined and exported
- handle_task_failure logs clear message and calls rollback
- handle_limit_reached logs reason and calls rollback
- File has proper header documenting all functions
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. File existence and syntax:
```bash
ls -la bin/lib/failfast.sh
bash -n bin/lib/failfast.sh && echo "Syntax OK"
```

2. Function existence:
```bash
source bin/lib/failfast.sh
type run_with_retry run_claude_task mark_checkpoint rollback_to_checkpoint check_limits handle_task_failure handle_limit_reached
```

3. Retry behavior test:
```bash
source bin/lib/failfast.sh
# Should see 3 attempts then fail
run_with_retry "false" "always-fail"
echo "Exit code: $?"  # Should be 1
```

4. Checkpoint test (in git repo):
```bash
source bin/lib/failfast.sh
mark_checkpoint
# Should output checkpoint SHA
```

5. Limit check test:
```bash
source bin/lib/failfast.sh
MAX_ITERATIONS=10
TIMEOUT_HOURS=1
START_TIME=$(date +%s)
check_limits 5 && echo "Within limits"
check_limits 10 && echo "Should not print" || echo "Limit reached"
```
</verification>

<success_criteria>
- bin/lib/failfast.sh exists with all 7 functions
- run_with_retry executes 3 attempts before failing
- run_with_retry returns immediately on success
- mark_checkpoint stores git HEAD
- rollback_to_checkpoint resets to stored checkpoint
- check_limits correctly detects iteration and timeout limits
- handle_task_failure and handle_limit_reached produce clear error messages
- File passes bash syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/01-safety-foundation/01-02-SUMMARY.md`
</output>
