---
phase: 03-outer-loop-core
plan: 02
type: execute
wave: 3
depends_on: ["03-01", "03-03"]
files_modified:
  - bin/lib/invoke.sh
  - bin/ralph.sh
autonomous: true

must_haves:
  truths:
    - "Claude Code CLI is invoked with -p flag for non-interactive execution"
    - "JSON output is parsed to extract result and detect errors"
    - "Failure triggers pause with Retry/Skip/Abort options"
    - "30-minute alert logged (no hard timeout)"
    - "Claude crash (non-zero exit) causes immediate ralph.sh abort"
    - "Skip option advances to next plan using get_next_plan_after"
  artifacts:
    - path: "bin/lib/invoke.sh"
      provides: "Claude CLI wrapper with output parsing"
      min_lines: 60
      exports: ["invoke_claude", "parse_claude_output"]
    - path: "bin/ralph.sh"
      provides: "Updated main loop with real Claude invocation"
      contains: "invoke_claude"
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/invoke.sh"
      via: "source statement"
      pattern: "source.*lib/invoke\\.sh"
    - from: "bin/lib/invoke.sh"
      to: "claude"
      via: "CLI invocation"
      pattern: "claude -p"
    - from: "bin/ralph.sh"
      to: "bin/lib/parse.sh"
      via: "get_next_plan_after for skip handling"
      pattern: "get_next_plan_after"
---

<objective>
Implement Claude CLI invocation with JSON output parsing and failure handling.

Purpose: This plan adds the actual Claude execution that makes ralph.sh functional - each iteration spawns a fresh Claude instance.
Output: Working invoke.sh library and ralph.sh integration that executes plans via Claude Code CLI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-outer-loop-core/03-CONTEXT.md
@.planning/phases/03-outer-loop-core/03-RESEARCH.md
@.planning/phases/03-outer-loop-core/03-01-SUMMARY.md
@.planning/phases/03-outer-loop-core/03-03-SUMMARY.md

# Existing infrastructure
@bin/ralph.sh
@bin/lib/parse.sh
@bin/lib/failfast.sh
@bin/lib/display.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invoke.sh with Claude CLI wrapper</name>
  <files>bin/lib/invoke.sh</files>
  <action>
Create bin/lib/invoke.sh with Claude invocation logic:

**invoke_claude function:**
- Args: task_id (e.g., "03-01")
- Find plan file using find_plan_file from parse.sh
- Build prompt that tells Claude to execute the plan:

```bash
prompt="Execute plan ${task_id}.

Read the plan file at ${plan_file}
Follow the execute-plan workflow from GSD.
Commit each task atomically.
Create SUMMARY.md when complete.
Update STATE.md with position and decisions."
```

- Create temp file for output: output_file=$(mktemp)
- Invoke Claude:
```bash
claude -p "$prompt" \
    --output-format json \
    --allowedTools "Bash,Read,Write,Edit,Glob,Grep,WebFetch" \
    > "$output_file" 2>&1
```
- Capture exit code
- Parse output and return result
- Clean up temp file

**parse_claude_output function:**
- Args: output_file
- Check if jq is available: `command -v jq &>/dev/null`
- If jq available: Extract result, cost_usd, session_id using jq
- If no jq: Use grep/sed fallback for basic extraction
- Return structured result (success/failure + summary)

**check_iteration_duration function:**
- Args: start_time
- Calculate elapsed time
- If > 30 minutes (1800 seconds), log warning to ralph.log
- Return 0 (no hard timeout per user decision)

Follow existing lib/ patterns:
- Use color codes matching display.sh
- Include file header comment
- Return exit codes for caller handling
  </action>
  <verify>
```bash
source bin/lib/invoke.sh
# Test that function is defined
type invoke_claude  # Should show function definition
type parse_claude_output  # Should show function definition
```
  </verify>
  <done>invoke.sh provides invoke_claude and parse_claude_output functions with jq/fallback JSON parsing</done>
</task>

<task type="auto">
  <name>Task 2: Add failure handling with interactive pause</name>
  <files>bin/lib/invoke.sh</files>
  <action>
Add handle_iteration_failure function to invoke.sh:

**handle_iteration_failure function:**
- Args: task_id, error_message
- Display failure prominently:
```bash
echo ""
echo -e "${RED}${BOLD}FAILURE: Task '$task_id' failed${RESET}"
echo -e "${RED}$error_message${RESET}"
echo ""
```

- Offer interactive options:
```bash
echo -e "Options:"
echo -e "  ${YELLOW}r${RESET} - Retry this task"
echo -e "  ${YELLOW}s${RESET} - Skip and continue to next task"
echo -e "  ${YELLOW}a${RESET} - Abort ralph loop"
echo ""
```

- Read user choice in loop until valid:
```bash
while true; do
    read -p "Choice [r/s/a]: " choice
    case "$choice" in
        r|R) return 0 ;;  # Retry
        s|S) return 1 ;;  # Skip
        a|A) return 2 ;;  # Abort
        *) echo "Invalid choice. Enter r, s, or a." ;;
    esac
done
```

**handle_claude_crash function:**
- Args: exit_code, task_id
- Called when Claude returns non-zero and it's not a normal failure
- Display crash message
- Return immediately (no retry option - abort)
  </action>
  <verify>
```bash
source bin/lib/invoke.sh
# Test function exists
type handle_iteration_failure
```
  </verify>
  <done>invoke.sh provides handle_iteration_failure with Retry/Skip/Abort options</done>
</task>

<task type="auto">
  <name>Task 3: Integrate invoke.sh into ralph.sh main loop</name>
  <files>bin/ralph.sh</files>
  <action>
Update ralph.sh to use invoke.sh for actual Claude execution:

**Add source statement:**
```bash
source "${SCRIPT_DIR}/lib/invoke.sh"
```

**Replace TODO placeholder in main loop with real invocation:**

```bash
# Track iteration timing
iteration_start=$(date +%s)

# Show running indicator (spinner from display.sh, added by 03-03)
start_spinner "[$iteration/$MAX_ITERATIONS] Running ${next_task}..."

# Invoke Claude
result=$(invoke_claude "$next_task")
exit_code=$?

stop_spinner

# Check for duration alert (30 min)
check_iteration_duration "$iteration_start"

# Calculate duration
iteration_end=$(date +%s)
duration=$((iteration_end - iteration_start))

# Handle result
if [[ $exit_code -eq 0 ]]; then
    # Success
    summary=$(parse_claude_output "$result" | head -1)
    show_status "[$iteration] Completed: $next_task ($duration s)" "success"
    add_iteration_entry "$iteration" "SUCCESS" "$next_task: $summary"
    log_iteration "$iteration" "SUCCESS" "$next_task" "$summary" "$duration"

    # Update progress
    completed=$(get_plans_completed)
    total=$(get_total_plans)
    update_progress "$completed" "$total"

    # Advance to next plan using get_next_plan_after from parse.sh
    next_plan=$(get_next_plan_after "$next_task")
    if [[ "$next_plan" == "COMPLETE" ]]; then
        update_next_action "COMPLETE" "All plans executed"
    else
        update_next_action "/gsd:execute-phase ${next_plan%%-*}" "Execute plan ${next_plan}"
    fi

    # Move checkpoint forward
    mark_checkpoint
else
    # Failure - pause for user decision
    handle_iteration_failure "$next_task" "$result"
    choice=$?

    case $choice in
        0)  # Retry
            add_iteration_entry "$iteration" "RETRY" "$next_task: Retrying..."
            continue  # Loop again on same task
            ;;
        1)  # Skip - advance to next plan
            add_iteration_entry "$iteration" "SKIPPED" "$next_task: Skipped by user"
            # Use get_next_plan_after to determine and set next task
            next_plan=$(get_next_plan_after "$next_task")
            if [[ "$next_plan" == "COMPLETE" ]]; then
                update_next_action "COMPLETE" "All plans executed (last task skipped)"
                show_status "All tasks complete (last was skipped)" "warning"
                break
            else
                update_next_action "/gsd:execute-phase ${next_plan%%-*}" "Execute plan ${next_plan} (skipped ${next_task})"
                show_status "Skipped $next_task, advancing to $next_plan" "warning"
            fi
            ;;
        2)  # Abort
            add_iteration_entry "$iteration" "ABORTED" "$next_task: User aborted"
            show_status "Aborted by user" "warning"
            exit 1
            ;;
    esac
fi
```

**Remove the placeholder break statement** that was added in 03-01.
  </action>
  <verify>
```bash
# Verify ralph.sh sources invoke.sh
grep -q "source.*invoke.sh" bin/ralph.sh && echo "invoke.sh sourced"

# Verify invoke_claude is called
grep -q "invoke_claude" bin/ralph.sh && echo "invoke_claude called"

# Verify skip handling uses get_next_plan_after
grep -q "get_next_plan_after" bin/ralph.sh && echo "get_next_plan_after used"

# Run ralph.sh (will attempt real Claude invocation)
./bin/ralph.sh
```
  </verify>
  <done>ralph.sh main loop invokes Claude via invoke.sh, handles success/failure with proper skip advancement using get_next_plan_after, and integrates with state updates</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `./bin/ralph.sh` attempts to invoke Claude (may fail if no plan ready, but should try)
2. invoke.sh functions are properly exported
3. JSON parsing works with jq if available, falls back to grep otherwise
4. Failure handling shows Retry/Skip/Abort options
5. Skip option correctly advances to next plan using get_next_plan_after
6. Duration alert triggers after 30 minutes (can test with mock)
</verification>

<success_criteria>
- Claude CLI is invoked with correct flags (-p, --output-format json, --allowedTools)
- JSON output is parsed to determine success/failure
- Failures pause execution with user choice
- Skip advances position using get_next_plan_after (not hardcoded)
- 30-minute duration alert is logged (no hard timeout)
- Non-zero Claude exit causes abort
- ralph.sh is now functional for actual plan execution
</success_criteria>

<output>
After completion, create `.planning/phases/03-outer-loop-core/03-02-SUMMARY.md`
</output>
