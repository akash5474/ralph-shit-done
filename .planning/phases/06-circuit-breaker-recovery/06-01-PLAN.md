---
phase: 06-circuit-breaker-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/exit.sh
  - bin/ralph.sh
autonomous: true

must_haves:
  truths:
    - "Loop pauses after N consecutive failures across different tasks"
    - "Interactive mode shows Resume/Skip/Abort menu when circuit breaker triggers"
    - "Non-interactive mode exits with STUCK status when circuit breaker triggers"
    - "Circuit breaker counter resets on user Resume action"
  artifacts:
    - path: "bin/lib/exit.sh"
      provides: "Circuit breaker tracking and pause handling"
      exports: ["check_circuit_breaker", "reset_circuit_breaker", "handle_circuit_breaker_pause", "CIRCUIT_BREAKER_THRESHOLD"]
    - path: "bin/ralph.sh"
      provides: "Main loop with circuit breaker integration"
      contains: "check_circuit_breaker"
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/exit.sh"
      via: "check_circuit_breaker call in failure handling"
      pattern: "check_circuit_breaker"
    - from: "handle_circuit_breaker_pause"
      to: "reset_circuit_breaker"
      via: "Resume option resets counter"
      pattern: "reset_circuit_breaker"
---

<objective>
Implement circuit breaker pattern that pauses execution after N consecutive failures across different tasks.

Purpose: Prevent token burn when systemic issues cause multiple tasks to fail in succession. Unlike stuck detection (same task failing), circuit breaker catches environment problems or cascading failures that affect multiple tasks.

Output: Extended exit.sh with circuit breaker functions, ralph.sh with integrated circuit breaker check.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-circuit-breaker-recovery/06-CONTEXT.md
@.planning/phases/06-circuit-breaker-recovery/06-RESEARCH.md
@bin/lib/exit.sh
@bin/lib/invoke.sh
@bin/ralph.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add circuit breaker state and functions to exit.sh</name>
  <files>bin/lib/exit.sh</files>
  <action>
Add to bin/lib/exit.sh AFTER the existing stuck detection state variables (around line 36):

1. Add new state variables in State Variables section:
```bash
# Circuit breaker tracking (failures across different tasks)
CROSS_TASK_FAILURES=0
CIRCUIT_BREAKER_THRESHOLD=5
```

2. Add new section after "Stuck Detection Functions" section (~line 93):
```bash
# =============================================================================
# Circuit Breaker Functions
# =============================================================================

# check_circuit_breaker - Check if failures across different tasks hit threshold
# Args: none (uses global CROSS_TASK_FAILURES)
# Returns: 0 if threshold reached (circuit open), 1 if not
# Side effect: Increments CROSS_TASK_FAILURES counter
# Note: Does NOT reset when task changes - that's the difference from stuck detection
check_circuit_breaker() {
    CROSS_TASK_FAILURES=$((CROSS_TASK_FAILURES + 1))

    if [[ "$CROSS_TASK_FAILURES" -ge "$CIRCUIT_BREAKER_THRESHOLD" ]]; then
        return 0  # Circuit breaker tripped
    fi
    return 1  # Circuit OK
}

# reset_circuit_breaker - Reset cross-task failure counter
# Called after user chooses Resume or on successful iteration
reset_circuit_breaker() {
    CROSS_TASK_FAILURES=0
}

# handle_circuit_breaker_pause - Interactive pause when circuit breaker trips
# Returns: 0 = Resume, 1 = Skip current task, 2 = Abort
# In non-interactive mode, exits with STUCK status (fail fast per CONTEXT.md)
handle_circuit_breaker_pause() {
    local current_task="${1:-unknown}"

    echo ""
    echo -e "${EXIT_YELLOW}${EXIT_BOLD}=== CIRCUIT BREAKER: $CROSS_TASK_FAILURES consecutive failures ===${EXIT_RESET}"
    echo -e "${EXIT_YELLOW}Multiple tasks failing - systemic issue suspected${EXIT_RESET}"
    echo ""

    # Check if interactive mode
    if [[ ! -t 0 ]]; then
        # Non-interactive: fail fast
        echo -e "${EXIT_RED}Non-interactive mode - exiting with STUCK status${EXIT_RESET}"
        return 2  # Signal abort
    fi

    echo -e "Options:"
    echo -e "  ${EXIT_YELLOW}r${EXIT_RESET} - Resume execution (reset circuit breaker)"
    echo -e "  ${EXIT_YELLOW}s${EXIT_RESET} - Skip current task and continue"
    echo -e "  ${EXIT_YELLOW}a${EXIT_RESET} - Abort ralph loop"
    echo ""

    while true; do
        read -p "Choice [r/s/a]: " choice
        case "$choice" in
            r|R)
                reset_circuit_breaker
                return 0  # Resume
                ;;
            s|S)
                reset_circuit_breaker
                return 1  # Skip
                ;;
            a|A)
                return 2  # Abort
                ;;
            *)
                echo "Invalid choice. Enter r, s, or a."
                ;;
        esac
    done
}
```

Key design decisions:
- CIRCUIT_BREAKER_THRESHOLD=5 (higher than STUCK_THRESHOLD=3 to avoid overlap)
- check_circuit_breaker increments counter unconditionally (unlike check_stuck which resets on task change)
- Non-interactive mode returns 2 (abort signal) - caller handles exit
- Reset happens on Resume AND Skip (both indicate user intervention)
  </action>
  <verify>
Run: `bash -n bin/lib/exit.sh` (syntax check passes)
Run: `grep -q "CIRCUIT_BREAKER_THRESHOLD" bin/lib/exit.sh` (returns 0)
Run: `grep -q "check_circuit_breaker" bin/lib/exit.sh` (returns 0)
Run: `grep -q "handle_circuit_breaker_pause" bin/lib/exit.sh` (returns 0)
  </verify>
  <done>
- CROSS_TASK_FAILURES and CIRCUIT_BREAKER_THRESHOLD=5 variables exist
- check_circuit_breaker() increments counter and returns 0 when threshold reached
- reset_circuit_breaker() resets counter to 0
- handle_circuit_breaker_pause() shows menu in interactive mode, returns abort signal in non-interactive
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate circuit breaker into ralph.sh main loop</name>
  <files>bin/ralph.sh</files>
  <action>
Modify bin/ralph.sh to check circuit breaker after each failure.

1. In the failure handling block (around line 335-380), AFTER check_stuck but BEFORE handle_iteration_failure, add circuit breaker check:

Find this block (approximately lines 343-347):
```bash
# Check if stuck on same task
if check_stuck "$next_task"; then
    loop_duration=$(($(date +%s) - START_TIME))
    exit_with_status "STUCK" "Same task failed $STUCK_THRESHOLD times" "$next_task" "$iteration" "$loop_duration"
    exit $EXIT_STUCK
fi
```

ADD immediately after it:
```bash
# Check circuit breaker (cross-task failures)
if check_circuit_breaker; then
    # Circuit breaker tripped - handle pause
    handle_circuit_breaker_pause "$next_task"
    cb_choice=$?

    case $cb_choice in
        0)  # Resume - counter already reset in handle_circuit_breaker_pause
            show_status "Circuit breaker reset - resuming..." "warning"
            # Fall through to normal failure handling below
            ;;
        1)  # Skip - advance to next task
            add_iteration_entry "$iteration" "SKIPPED" "$next_task: Skipped after circuit breaker"
            next_plan=$(get_next_plan_after "$next_task")
            if [[ "$next_plan" == "COMPLETE" ]]; then
                update_next_action "COMPLETE" "COMPLETE" "All plans executed (last task skipped)"
                show_status "All tasks complete (last was skipped)" "warning"
                loop_duration=$(($(date +%s) - START_TIME))
                exit_with_status "COMPLETED" "All plans done (last skipped)" "$next_task" "$iteration" "$loop_duration"
                exit $EXIT_COMPLETED
            else
                skip_phase_num="${next_plan%%-*}"
                skip_plan_name=$(get_plan_name "$next_plan")
                update_next_action "$skip_phase_num" "$next_plan" "$skip_plan_name (skipped ${next_task})"
                show_status "Skipped $next_task, advancing to $next_plan" "warning"
                continue  # Next iteration
            fi
            ;;
        2)  # Abort
            add_iteration_entry "$iteration" "ABORTED" "$next_task: User aborted at circuit breaker"
            loop_duration=$(($(date +%s) - START_TIME))
            exit_with_status "ABORTED" "User aborted at circuit breaker" "$next_task" "$iteration" "$loop_duration"
            exit $EXIT_ABORTED
            ;;
    esac
fi
```

2. Also reset circuit breaker on SUCCESS (around line 304 where reset_failure_tracking is called):
Find:
```bash
# Reset stuck detection on success
reset_failure_tracking
```
Add immediately after:
```bash
# Reset circuit breaker on success
reset_circuit_breaker
```

Key integration points:
- Circuit breaker check runs AFTER stuck check (stuck is more specific)
- Skip handling reuses existing get_next_plan_after pattern
- Success resets both stuck detection AND circuit breaker
- All paths properly log to iteration history
  </action>
  <verify>
Run: `bash -n bin/ralph.sh` (syntax check passes)
Run: `grep -q "check_circuit_breaker" bin/ralph.sh` (returns 0)
Run: `grep -q "reset_circuit_breaker" bin/ralph.sh` (returns 0)
Run: `grep -c "circuit" bin/ralph.sh` (returns at least 5 - multiple references)
  </verify>
  <done>
- ralph.sh calls check_circuit_breaker() after check_stuck() on failure
- Circuit breaker pause handled with Resume/Skip/Abort options
- Skip advances to next task using existing get_next_plan_after logic
- Success path resets circuit breaker counter
- All state changes logged to iteration history
  </done>
</task>

</tasks>

<verification>
Manual verification:
1. Source exit.sh and verify new functions exist:
   ```bash
   source bin/lib/exit.sh
   type check_circuit_breaker
   type reset_circuit_breaker
   type handle_circuit_breaker_pause
   echo "Threshold: $CIRCUIT_BREAKER_THRESHOLD"
   ```

2. Test circuit breaker logic (dry run):
   ```bash
   source bin/lib/exit.sh
   # Simulate 4 failures (below threshold)
   for i in 1 2 3 4; do check_circuit_breaker && echo "TRIPPED" || echo "OK ($CROSS_TASK_FAILURES)"; done
   # 5th failure trips it
   check_circuit_breaker && echo "TRIPPED at $CROSS_TASK_FAILURES" || echo "Still OK"
   ```

3. Verify ralph.sh syntax:
   ```bash
   bash -n bin/ralph.sh && echo "Syntax OK"
   ```
</verification>

<success_criteria>
- Circuit breaker functions added to exit.sh (check, reset, handle_pause)
- CIRCUIT_BREAKER_THRESHOLD=5 (higher than STUCK_THRESHOLD=3)
- ralph.sh integrates circuit breaker check in failure path
- Interactive mode shows Resume/Skip/Abort menu
- Non-interactive mode fails fast with abort signal
- Success path resets circuit breaker counter
- All syntax checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-circuit-breaker-recovery/06-01-SUMMARY.md`
</output>
