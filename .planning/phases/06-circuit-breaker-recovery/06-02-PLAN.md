---
phase: 06-circuit-breaker-recovery
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - bin/lib/recovery.sh
  - bin/lib/exit.sh
  - bin/ralph.sh
autonomous: true

must_haves:
  truths:
    - "Stuck analysis examines recent failure entries from STATE.md"
    - "Analysis identifies common patterns (same error, same file)"
    - "Analysis summary is 3-5 lines (not verbose)"
    - "Analysis is shown before Resume/Skip/Abort menu"
  artifacts:
    - path: "bin/lib/recovery.sh"
      provides: "Stuck analysis and pattern detection"
      exports: ["generate_stuck_analysis", "parse_failure_patterns"]
    - path: "bin/lib/exit.sh"
      provides: "Circuit breaker pause with analysis integration"
      contains: "generate_stuck_analysis"
    - path: "bin/ralph.sh"
      provides: "Sources recovery.sh library"
      contains: "source.*recovery.sh"
  key_links:
    - from: "bin/lib/exit.sh"
      to: "bin/lib/recovery.sh"
      via: "generate_stuck_analysis call in handle_circuit_breaker_pause"
      pattern: "generate_stuck_analysis"
    - from: "bin/lib/recovery.sh"
      to: ".planning/STATE.md"
      via: "sed parsing of HISTORY section"
      pattern: "HISTORY_START.*HISTORY_END"
---

<objective>
Implement stuck analysis that examines recent failure patterns before showing the circuit breaker pause menu.

Purpose: Give users actionable information about WHY the loop is stuck, helping them decide whether to Resume, Skip, or Abort. Analysis examines recent failure entries from STATE.md to identify common patterns.

Output: New recovery.sh library with analysis functions, integration into circuit breaker pause screen.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-circuit-breaker-recovery/06-CONTEXT.md
@.planning/phases/06-circuit-breaker-recovery/06-RESEARCH.md
@.planning/phases/06-circuit-breaker-recovery/06-01-SUMMARY.md
@bin/lib/exit.sh
@bin/lib/state.sh
@bin/ralph.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recovery.sh library with stuck analysis</name>
  <files>bin/lib/recovery.sh</files>
  <action>
Create new file bin/lib/recovery.sh with stuck analysis functions:

```bash
#!/bin/bash
# GSD Ralph - Recovery and Stuck Analysis
# Part of Phase 6: Circuit Breaker & Recovery
#
# Provides stuck analysis functions that examine failure patterns in STATE.md.
# Functions: generate_stuck_analysis, parse_failure_patterns, get_recent_failures
#
# Usage:
#   source bin/lib/recovery.sh
#   generate_stuck_analysis  # Outputs 3-5 line analysis to stdout

# Configuration
STATE_FILE="${STATE_FILE:-.planning/STATE.md}"
ANALYSIS_WINDOW=5  # Number of recent failures to analyze

# Color codes (respect NO_COLOR standard)
if [[ -n "${NO_COLOR:-}" ]]; then
    RECOVERY_YELLOW=''
    RECOVERY_CYAN=''
    RECOVERY_BOLD=''
    RECOVERY_RESET=''
else
    RECOVERY_YELLOW='\e[33m'
    RECOVERY_CYAN='\e[36m'
    RECOVERY_BOLD='\e[1m'
    RECOVERY_RESET='\e[0m'
fi

# =============================================================================
# Failure Pattern Analysis Functions
# =============================================================================

# get_recent_failures - Extract recent FAILURE entries from STATE.md history
# Args: [count] - number of entries to get (default: ANALYSIS_WINDOW)
# Output: Failure entries, one per line
# Returns: 0 on success, 1 if no failures found
get_recent_failures() {
    local count="${1:-$ANALYSIS_WINDOW}"

    if [[ ! -f "$STATE_FILE" ]]; then
        return 1
    fi

    # Extract entries from history section that contain FAILURE
    local failures
    failures=$(sed -n '/<!-- HISTORY_START -->/,/<!-- HISTORY_END -->/{
        /FAILURE/p
    }' "$STATE_FILE" | head -n "$count")

    if [[ -z "$failures" ]]; then
        return 1
    fi

    echo "$failures"
    return 0
}

# parse_failure_patterns - Analyze failures for common patterns
# Args: failure_entries (multiline string)
# Output: Sets global variables: PATTERN_ERROR, PATTERN_FILE, PATTERN_TASK_PREFIX
# Returns: 0 if patterns found, 1 if no clear patterns
parse_failure_patterns() {
    local failures="$1"

    PATTERN_ERROR=""
    PATTERN_FILE=""
    PATTERN_TASK_PREFIX=""

    if [[ -z "$failures" ]]; then
        return 1
    fi

    # Pattern 1: Look for repeated error keywords
    # Common patterns: "Error:", "Failed:", "cannot", "not found"
    local error_counts
    error_counts=$(echo "$failures" | grep -oiE '(error|failed|cannot|not found)[^|]*' | \
        sed 's/[[:space:]]*$//' | sort | uniq -c | sort -rn | head -1)

    if [[ -n "$error_counts" ]]; then
        # Extract just the pattern (remove count)
        PATTERN_ERROR=$(echo "$error_counts" | sed 's/^[[:space:]]*[0-9]*[[:space:]]*//')
    fi

    # Pattern 2: Look for repeated file references
    # Match common file extensions
    local file_counts
    file_counts=$(echo "$failures" | grep -oE '[a-zA-Z0-9_/-]+\.(sh|md|ts|js|tsx|jsx|json|yaml|yml)' | \
        sort | uniq -c | sort -rn | head -1)

    if [[ -n "$file_counts" ]]; then
        local count=$(echo "$file_counts" | awk '{print $1}')
        if [[ "$count" -gt 1 ]]; then
            PATTERN_FILE=$(echo "$file_counts" | awk '{print $2}')
        fi
    fi

    # Pattern 3: Look for repeated task prefixes (same phase)
    # Task IDs are like "05-01", "05-02" - check if same phase failing
    local task_prefix_counts
    task_prefix_counts=$(echo "$failures" | grep -oE '[0-9]{2}-[0-9]{2}' | \
        cut -d'-' -f1 | sort | uniq -c | sort -rn | head -1)

    if [[ -n "$task_prefix_counts" ]]; then
        local count=$(echo "$task_prefix_counts" | awk '{print $1}')
        if [[ "$count" -gt 1 ]]; then
            PATTERN_TASK_PREFIX=$(echo "$task_prefix_counts" | awk '{print $2}')
        fi
    fi

    # Return success if any pattern found
    [[ -n "$PATTERN_ERROR" || -n "$PATTERN_FILE" || -n "$PATTERN_TASK_PREFIX" ]]
}

# generate_stuck_analysis - Generate 3-5 line analysis summary
# Output: Analysis text to stdout (colorized if terminal)
# Returns: 0 always
#
# This is the main entry point called by handle_circuit_breaker_pause
generate_stuck_analysis() {
    local failures
    local failure_count=0

    # Get recent failures
    failures=$(get_recent_failures)
    if [[ $? -ne 0 || -z "$failures" ]]; then
        echo -e "${RECOVERY_YELLOW}Analysis:${RECOVERY_RESET} No recent failures in history to analyze"
        return 0
    fi

    # Count failures
    failure_count=$(echo "$failures" | wc -l | tr -d ' ')

    echo -e "${RECOVERY_YELLOW}${RECOVERY_BOLD}Failure Analysis:${RECOVERY_RESET}"

    # Parse for patterns
    parse_failure_patterns "$failures"

    local patterns_found=false

    # Report error pattern if found
    if [[ -n "$PATTERN_ERROR" ]]; then
        echo -e "  ${RECOVERY_CYAN}Common error:${RECOVERY_RESET} $PATTERN_ERROR"
        patterns_found=true
    fi

    # Report file pattern if found
    if [[ -n "$PATTERN_FILE" ]]; then
        echo -e "  ${RECOVERY_CYAN}Affected file:${RECOVERY_RESET} $PATTERN_FILE"
        patterns_found=true
    fi

    # Report task prefix pattern if found
    if [[ -n "$PATTERN_TASK_PREFIX" ]]; then
        echo -e "  ${RECOVERY_CYAN}Failing phase:${RECOVERY_RESET} Phase $PATTERN_TASK_PREFIX"
        patterns_found=true
    fi

    if [[ "$patterns_found" != "true" ]]; then
        echo -e "  ${RECOVERY_CYAN}Pattern:${RECOVERY_RESET} No clear pattern detected in $failure_count failures"
    fi

    # Provide suggestion based on patterns
    echo ""
    if [[ -n "$PATTERN_FILE" ]]; then
        echo -e "  ${RECOVERY_YELLOW}Suggestion:${RECOVERY_RESET} Check $PATTERN_FILE for issues"
    elif [[ -n "$PATTERN_ERROR" ]]; then
        echo -e "  ${RECOVERY_YELLOW}Suggestion:${RECOVERY_RESET} Investigate the recurring error above"
    else
        echo -e "  ${RECOVERY_YELLOW}Suggestion:${RECOVERY_RESET} Review recent changes or environment setup"
    fi

    return 0
}
```

Key design decisions:
- ANALYSIS_WINDOW=5 matches CIRCUIT_BREAKER_THRESHOLD
- Parses STATE.md history using established sed patterns from state.sh
- Three pattern types: error keywords, file references, task prefixes
- Output is 3-5 lines as specified in CONTEXT.md
- Colors match existing codebase (YELLOW for warnings, CYAN for info)
  </action>
  <verify>
Run: `bash -n bin/lib/recovery.sh` (syntax check passes)
Run: `test -f bin/lib/recovery.sh && echo "File exists"`
Run: `grep -q "generate_stuck_analysis" bin/lib/recovery.sh` (returns 0)
Run: `grep -q "parse_failure_patterns" bin/lib/recovery.sh` (returns 0)
Run: `grep -q "ANALYSIS_WINDOW" bin/lib/recovery.sh` (returns 0)
  </verify>
  <done>
- bin/lib/recovery.sh created with stuck analysis functions
- get_recent_failures extracts FAILURE entries from STATE.md
- parse_failure_patterns identifies common error, file, and phase patterns
- generate_stuck_analysis outputs 3-5 line colorized summary
- All functions follow established codebase patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate analysis into circuit breaker pause</name>
  <files>bin/lib/exit.sh, bin/ralph.sh</files>
  <action>
1. Modify bin/lib/exit.sh handle_circuit_breaker_pause() to call generate_stuck_analysis:

Find the handle_circuit_breaker_pause function (added in 06-01). After the "systemic issue suspected" line and before the interactive check, add the analysis call:

```bash
# After:
echo -e "${EXIT_YELLOW}Multiple tasks failing - systemic issue suspected${EXIT_RESET}"
echo ""

# ADD:
# Show stuck analysis if recovery.sh is sourced
if type generate_stuck_analysis &>/dev/null; then
    generate_stuck_analysis
    echo ""
fi
```

The full modified section should look like:
```bash
handle_circuit_breaker_pause() {
    local current_task="${1:-unknown}"

    echo ""
    echo -e "${EXIT_YELLOW}${EXIT_BOLD}=== CIRCUIT BREAKER: $CROSS_TASK_FAILURES consecutive failures ===${EXIT_RESET}"
    echo -e "${EXIT_YELLOW}Multiple tasks failing - systemic issue suspected${EXIT_RESET}"
    echo ""

    # Show stuck analysis if recovery.sh is sourced
    if type generate_stuck_analysis &>/dev/null; then
        generate_stuck_analysis
        echo ""
    fi

    # Check if interactive mode
    if [[ ! -t 0 ]]; then
        # ... rest of function unchanged
```

2. Modify bin/ralph.sh to source recovery.sh library:

Find the library source block (around lines 22-29):
```bash
source "${SCRIPT_DIR}/lib/budget.sh"
source "${SCRIPT_DIR}/lib/state.sh"
source "${SCRIPT_DIR}/lib/display.sh"
source "${SCRIPT_DIR}/lib/failfast.sh"
source "${SCRIPT_DIR}/lib/parse.sh"
source "${SCRIPT_DIR}/lib/invoke.sh"
source "${SCRIPT_DIR}/lib/checkpoint.sh"
source "${SCRIPT_DIR}/lib/exit.sh"
```

Add after exit.sh:
```bash
source "${SCRIPT_DIR}/lib/recovery.sh"
```

Key integration points:
- Analysis is shown BEFORE the options menu
- Uses `type ... &>/dev/null` check for safe optional dependency
- Recovery.sh must be sourced AFTER exit.sh in ralph.sh
  </action>
  <verify>
Run: `bash -n bin/lib/exit.sh` (syntax check passes)
Run: `bash -n bin/ralph.sh` (syntax check passes)
Run: `grep -q "generate_stuck_analysis" bin/lib/exit.sh` (returns 0)
Run: `grep -q "recovery.sh" bin/ralph.sh` (returns 0)
  </verify>
  <done>
- handle_circuit_breaker_pause calls generate_stuck_analysis before showing menu
- ralph.sh sources recovery.sh library
- Analysis is conditionally called (safe if recovery.sh not sourced)
- Both files pass syntax check
  </done>
</task>

<task type="auto">
  <name>Task 3: Add alternative approach hint to analysis</name>
  <files>bin/lib/recovery.sh</files>
  <action>
Enhance generate_stuck_analysis to provide "alternative approach" hints per LOOP-04 requirement.

In bin/lib/recovery.sh, update the suggestion section at the end of generate_stuck_analysis():

Replace the simple suggestion block with pattern-aware alternatives:

```bash
    # Provide actionable suggestion based on patterns (LOOP-04: alternative approaches)
    echo ""
    echo -e "  ${RECOVERY_YELLOW}Possible actions:${RECOVERY_RESET}"

    if [[ -n "$PATTERN_FILE" ]]; then
        echo -e "    - Check $PATTERN_FILE for syntax errors or missing dependencies"
        echo -e "    - Review recent changes to this file (git diff)"
    fi

    if [[ -n "$PATTERN_ERROR" ]]; then
        echo -e "    - Search codebase for similar issues: grep -r '$PATTERN_ERROR'"
    fi

    if [[ -n "$PATTERN_TASK_PREFIX" ]]; then
        echo -e "    - Phase $PATTERN_TASK_PREFIX may have environmental prerequisites"
        echo -e "    - Consider running earlier phase plans first"
    fi

    if [[ "$patterns_found" != "true" ]]; then
        echo -e "    - Check environment (missing tools, permissions, network)"
        echo -e "    - Review .planning/ralph.log for detailed error output"
        echo -e "    - Try running the failing task manually"
    fi
```

This provides context-aware suggestions that help users understand alternatives before deciding Resume/Skip/Abort.
  </action>
  <verify>
Run: `bash -n bin/lib/recovery.sh` (syntax check passes)
Run: `grep -q "Possible actions" bin/lib/recovery.sh` (returns 0)
Run: `grep -q "git diff" bin/lib/recovery.sh` (returns 0)
  </verify>
  <done>
- generate_stuck_analysis provides pattern-aware alternative action hints
- File-related failures suggest checking the file and git diff
- Error-related failures suggest grep search
- Phase-related failures suggest prerequisite check
- Generic failures suggest environment and manual testing
- Output stays within 3-5 line target (each pattern adds 1-2 lines)
  </done>
</task>

</tasks>

<verification>
Integration test (requires populated STATE.md history):

1. Source all libraries and verify analysis works:
```bash
source bin/lib/state.sh
source bin/lib/exit.sh
source bin/lib/recovery.sh

# Test analysis generation (output depends on STATE.md content)
generate_stuck_analysis
```

2. Verify circuit breaker pause shows analysis:
```bash
# Mock test - set threshold low temporarily
source bin/lib/exit.sh
source bin/lib/recovery.sh
CIRCUIT_BREAKER_THRESHOLD=1

# This would trigger pause with analysis (don't run in non-interactive)
# check_circuit_breaker && handle_circuit_breaker_pause "test-task"
```

3. Full syntax validation:
```bash
bash -n bin/lib/recovery.sh && echo "recovery.sh OK"
bash -n bin/lib/exit.sh && echo "exit.sh OK"
bash -n bin/ralph.sh && echo "ralph.sh OK"
```
</verification>

<success_criteria>
- recovery.sh library created with analysis functions
- generate_stuck_analysis outputs 3-5 line summary
- Analysis identifies: common errors, affected files, failing phases
- Alternative approach hints provided based on patterns
- Integration: ralph.sh sources recovery.sh, exit.sh calls generate_stuck_analysis
- All syntax checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-circuit-breaker-recovery/06-02-SUMMARY.md`
</output>
