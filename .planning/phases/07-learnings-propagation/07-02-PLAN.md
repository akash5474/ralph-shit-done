---
phase: 07-learnings-propagation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - bin/lib/invoke.sh
  - bin/ralph.sh
autonomous: true

must_haves:
  truths:
    - "Claude prompt includes relevant learnings for the current phase"
    - "Learnings are extracted after successful iteration completion"
    - "Log shows 'Applied learning' attribution when learnings help"
  artifacts:
    - path: "bin/lib/invoke.sh"
      provides: "Learning injection into Claude prompt"
      contains: "get_learnings_for_phase"
    - path: "bin/ralph.sh"
      provides: "Learning extraction after success"
      contains: "extract_learnings_from_summary"
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/learnings.sh"
      via: "source statement"
      pattern: 'source.*learnings\.sh'
    - from: "bin/lib/invoke.sh"
      to: "get_learnings_for_phase"
      via: "function call in prompt builder"
      pattern: "get_learnings_for_phase"
---

<objective>
Integrate learnings into Claude invocation and extraction loop

Purpose: Wire the learnings.sh library into the ralph loop so that learnings are (1) injected into Claude's prompt at the start of each iteration and (2) extracted from SUMMARY.md after successful completion.

Output: Modified invoke.sh with learning injection, modified ralph.sh with learning extraction and sourcing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-learnings-propagation/07-CONTEXT.md
@.planning/phases/07-learnings-propagation/07-RESEARCH.md
@.planning/phases/07-learnings-propagation/07-01-SUMMARY.md

# Files to modify
@bin/lib/invoke.sh
@bin/ralph.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Source learnings.sh in ralph.sh</name>
  <files>bin/ralph.sh</files>
  <action>
Add learnings.sh to the source block in ralph.sh, after recovery.sh:

```bash
source "${SCRIPT_DIR}/lib/learnings.sh"
```

The source block should now include:
- budget.sh
- state.sh
- display.sh
- failfast.sh
- parse.sh
- invoke.sh
- checkpoint.sh
- exit.sh
- recovery.sh
- learnings.sh  (NEW)

This makes all learnings functions available to ralph.sh and invoke.sh.
  </action>
  <verify>
Run: `bash -n bin/ralph.sh` - Should have no syntax errors
Check: Source line for learnings.sh appears after recovery.sh
  </verify>
  <done>
- ralph.sh sources learnings.sh
- No syntax errors in ralph.sh
  </done>
</task>

<task type="auto">
  <name>Task 2: Inject learnings into Claude prompt in invoke.sh</name>
  <files>bin/lib/invoke.sh</files>
  <action>
Modify invoke_claude() function in invoke.sh to include learnings in the prompt.

After building the base prompt and before invoking Claude:

1. Extract phase number from task_id: `local phase_num="${task_id%%-*}"`
2. Get relevant learnings: `local learnings=$(get_learnings_for_phase "$phase_num")`
3. If learnings are non-empty, append to prompt:

```bash
# Get relevant learnings for this phase
local phase_num="${task_id%%-*}"
local learnings=""
if type get_learnings_for_phase &>/dev/null; then
    learnings=$(get_learnings_for_phase "$phase_num" 2>/dev/null || true)
fi

# Build the prompt
local prompt
prompt="Execute plan ${task_id}.

Read the plan file at ${plan_file}
Follow the execute-plan workflow from GSD.
Commit each task atomically.
Create SUMMARY.md when complete.
Update STATE.md with position and decisions."

# Add learnings if available
if [[ -n "$learnings" && "$learnings" =~ [^[:space:]] ]]; then
    prompt+="

## Project Learnings (apply when relevant)

${learnings}"
fi
```

Use type check (`type get_learnings_for_phase &>/dev/null`) for safe optional dependency, same pattern as recovery.sh integration in exit.sh.
  </action>
  <verify>
1. Source all libs: `source bin/lib/*.sh`
2. Create test AGENTS.md with a learning entry
3. Trace invoke_claude to see prompt includes learnings section
   (Or add `echo "$prompt" >&2` temporarily for debugging)
  </verify>
  <done>
- invoke_claude includes learnings in prompt when available
- Uses safe optional dependency pattern (type check)
- Learnings appear under "## Project Learnings" header
  </done>
</task>

<task type="auto">
  <name>Task 3: Extract learnings after successful iteration</name>
  <files>bin/ralph.sh</files>
  <action>
In the success handling block of ralph.sh (inside `if [[ $exit_code -eq 0 ]]; then`), after handle_iteration_success but before checkpoint commit:

1. Find the SUMMARY.md file for the completed task:
   - SUMMARY file pattern: `.planning/phases/{phase-name}/{task_id}-SUMMARY.md`
   - Use find_plan_file logic but for SUMMARY instead of PLAN

2. Call extract_learnings_from_summary if SUMMARY exists:

```bash
# Extract learnings from completed task's SUMMARY.md
if type extract_learnings_from_summary &>/dev/null; then
    # Find SUMMARY file (same location as PLAN file but different suffix)
    local summary_file
    summary_file=$(find .planning/phases -name "${next_task}-SUMMARY.md" 2>/dev/null | head -1)
    if [[ -n "$summary_file" && -f "$summary_file" ]]; then
        extract_learnings_from_summary "$summary_file" "$next_task"
        # Prune if getting too large
        prune_agents_if_needed
    fi
fi
```

Place this code block:
- After: `handle_iteration_success "$iteration" "$next_task" "$summary" "$iteration_duration"`
- Before: `enter_critical_section` (checkpoint commit)

This ensures learnings are extracted after each successful plan completion, before the checkpoint commit. The checkpoint will include any new learnings.
  </action>
  <verify>
1. Create a mock SUMMARY.md with patterns-established frontmatter
2. Run ralph.sh manually (or trace the code path)
3. Verify AGENTS.md gets updated with patterns from the summary
  </verify>
  <done>
- ralph.sh extracts learnings after successful iteration
- Uses safe optional dependency pattern
- Learnings extraction happens before checkpoint (included in commit)
- Prune check runs after extraction
  </done>
</task>

</tasks>

<verification>
End-to-end verification:
1. `bash -n bin/ralph.sh` - No syntax errors
2. `bash -n bin/lib/invoke.sh` - No syntax errors
3. Source all libs and verify functions available
4. Create test AGENTS.md, verify learnings appear in prompt
5. Create test SUMMARY.md, run extraction, verify AGENTS.md updated
</verification>

<success_criteria>
- ralph.sh sources learnings.sh without errors
- invoke_claude injects learnings into prompt when available
- Success handler extracts learnings from SUMMARY.md
- Safe optional dependency pattern used (type checks)
- Learnings extraction happens before checkpoint commit
- All modifications maintain existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/07-learnings-propagation/07-02-SUMMARY.md`
</output>
