---
phase: 05-exit-conditions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [bin/lib/exit.sh, bin/ralph.sh]
autonomous: true

must_haves:
  truths:
    - "Loop detects when same task fails 3 times consecutively"
    - "Loop exits with STUCK status when threshold reached"
    - "Ctrl+C finishes current iteration before exiting"
    - "Exit reason is logged to STATE.md"
  artifacts:
    - path: "bin/lib/exit.sh"
      provides: "Exit condition detection functions"
      exports: ["check_stuck", "handle_interrupt", "exit_with_status"]
    - path: "bin/ralph.sh"
      provides: "Main loop with stuck detection and interrupt handling"
      contains: "source.*exit.sh"
  key_links:
    - from: "bin/ralph.sh"
      to: "bin/lib/exit.sh"
      via: "source statement and function calls"
      pattern: "check_stuck|handle_interrupt"
    - from: "bin/ralph.sh failure path"
      to: "check_stuck"
      via: "function call after failure"
      pattern: "check_stuck.*\\$task"
---

<objective>
Create exit.sh library with stuck detection, graceful interrupt handling, and exit status logging.

Purpose: Implement EXIT-02 (stuck loop detection) and EXIT-03 infrastructure (exit status tracking). This provides the foundation for determining when autonomous execution should stop.

Output: New exit.sh library with check_stuck(), handle_interrupt(), exit_with_status() functions. ralph.sh wired to detect stuck loops and handle Ctrl+C gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-exit-conditions/05-CONTEXT.md
@.planning/phases/05-exit-conditions/05-RESEARCH.md
@bin/ralph.sh
@bin/lib/display.sh
@bin/lib/state.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exit.sh with stuck detection and exit status functions</name>
  <files>bin/lib/exit.sh</files>
  <action>
Create new exit.sh library with:

1. Global state variables:
   - CONSECUTIVE_FAILURES=0
   - LAST_FAILED_TASK=""
   - STUCK_THRESHOLD=3
   - INTERRUPTED=false
   - IN_CRITICAL_SECTION=false

2. Exit code constants (from CONTEXT.md):
   - EXIT_COMPLETED=0
   - EXIT_STUCK=1
   - EXIT_ABORTED=2
   - EXIT_INTERRUPTED=3

3. check_stuck() function:
   - Args: task_id (string)
   - If task_id == LAST_FAILED_TASK: increment CONSECUTIVE_FAILURES
   - If task_id != LAST_FAILED_TASK: reset CONSECUTIVE_FAILURES=1, update LAST_FAILED_TASK
   - If CONSECUTIVE_FAILURES >= STUCK_THRESHOLD: return 1 (stuck)
   - Otherwise: return 0 (not stuck)

4. reset_failure_tracking() function:
   - Called on success to reset CONSECUTIVE_FAILURES=0 and LAST_FAILED_TASK=""

5. handle_interrupt() function (SIGINT handler):
   - If IN_CRITICAL_SECTION: set INTERRUPTED=true and return (defer handling)
   - Otherwise: print message and set INTERRUPTED=true

6. check_interrupted() function:
   - Returns 0 if INTERRUPTED=true, 1 otherwise
   - Used to check flag at safe points in main loop

7. enter_critical_section() / exit_critical_section() helpers:
   - Set/clear IN_CRITICAL_SECTION flag
   - exit_critical_section checks if interrupt was deferred

8. exit_with_status() function:
   - Args: status (COMPLETED/STUCK/ABORTED/INTERRUPTED), reason, last_task, iteration_count, duration
   - Calls log_exit_status (Task 2 will add to state.sh)
   - Prints terminal message with appropriate color
   - Returns the exit code (does NOT call exit - caller decides)

Use NO_COLOR pattern from display.sh for color codes.
Include proper header comment documenting functions.
  </action>
  <verify>
bash -n bin/lib/exit.sh  # Syntax check
grep -q "check_stuck" bin/lib/exit.sh
grep -q "handle_interrupt" bin/lib/exit.sh
grep -q "STUCK_THRESHOLD=3" bin/lib/exit.sh
  </verify>
  <done>exit.sh exists with check_stuck, handle_interrupt, exit_with_status functions and all state variables</done>
</task>

<task type="auto">
  <name>Task 2: Add exit logging function to state.sh</name>
  <files>bin/lib/state.sh</files>
  <action>
Add log_exit_status() function to state.sh:

Args: status, reason, last_task, iteration_count, duration

Function behavior:
1. Update STATUS line in STATE.md from "In progress" to the status value
2. Add final iteration entry with the exit reason
3. Optionally add next-steps guidance based on exit status (Claude's discretion per CONTEXT.md):
   - STUCK: "Review task {last_task} and fix the issue before restarting"
   - ABORTED: "Run ./bin/ralph.sh to continue from current position"
   - COMPLETED: "Milestone complete!"
   - INTERRUPTED: "Run ./bin/ralph.sh to resume"

Use sed to update the Status line in Current Position section.
Use add_iteration_entry for the final history entry.
  </action>
  <verify>
bash -n bin/lib/state.sh  # Syntax check
grep -q "log_exit_status" bin/lib/state.sh
  </verify>
  <done>log_exit_status function exists in state.sh, updates Status line and adds final history entry</done>
</task>

<task type="auto">
  <name>Task 3: Wire stuck detection and interrupt handling into ralph.sh</name>
  <files>bin/ralph.sh</files>
  <action>
Modify ralph.sh to integrate exit.sh:

1. Add source statement after other lib sources:
   source "${SCRIPT_DIR}/lib/exit.sh"

2. Set up SIGINT trap BEFORE main loop (after startup validation):
   trap 'handle_interrupt' INT

3. In the main loop, after successful iteration:
   - Call reset_failure_tracking() to clear stuck counter

4. In the failure path (after handle_iteration_failure_state), BEFORE presenting user choice:
   - Call check_stuck "$next_task"
   - If returns 1 (stuck):
     - Calculate duration using START_TIME
     - Call exit_with_status "STUCK" "Same task failed $STUCK_THRESHOLD times" "$next_task" "$iteration" "$duration"
     - Exit with EXIT_STUCK code
   - If returns 0 (not stuck): continue to Retry/Skip/Abort menu as before

5. At END of each iteration (after checkpoint commit OR failure handling), check for deferred interrupt:
   - Call check_interrupted
   - If true:
     - Create final checkpoint if needed
     - Call exit_with_status "INTERRUPTED" "User interrupt" "$next_task" "$iteration" "$duration"
     - Exit with EXIT_INTERRUPTED code

6. Protect critical sections (git commit, STATE.md write):
   - Wrap create_checkpoint_commit with enter_critical_section/exit_critical_section

7. Update the post-loop completion message to use exit_with_status:
   - Call exit_with_status "COMPLETED" "All tasks complete" "$next_task" "$iteration" "$duration"
   - Exit with EXIT_COMPLETED code

8. Update handle_limit_reached call to use exit_with_status:
   - Call exit_with_status "ABORTED" "Iteration cap reached" "$next_task" "$iteration" "$duration"
   - Exit with EXIT_ABORTED code

Important: Do NOT use "exit" inside functions - return exit codes and let the main script handle actual exit.
  </action>
  <verify>
bash -n bin/ralph.sh  # Syntax check
grep -q "source.*exit.sh" bin/ralph.sh
grep -q "trap.*handle_interrupt.*INT" bin/ralph.sh
grep -q "check_stuck" bin/ralph.sh
grep -q "exit_with_status" bin/ralph.sh
  </verify>
  <done>ralph.sh sources exit.sh, has SIGINT trap, calls check_stuck on failure, uses exit_with_status for all exit paths</done>
</task>

</tasks>

<verification>
Run syntax checks on all modified files:
```bash
bash -n bin/lib/exit.sh
bash -n bin/lib/state.sh
bash -n bin/ralph.sh
```

Verify integration:
```bash
# Check exit.sh is sourced
grep "source.*exit.sh" bin/ralph.sh

# Check trap is set
grep "trap.*INT" bin/ralph.sh

# Check stuck detection is wired
grep "check_stuck" bin/ralph.sh

# Check all exit paths use exit_with_status
grep -c "exit_with_status" bin/ralph.sh  # Should be >= 4 (COMPLETED, STUCK, ABORTED, INTERRUPTED)
```
</verification>

<success_criteria>
- exit.sh exists with check_stuck(), handle_interrupt(), exit_with_status() functions
- state.sh has log_exit_status() function
- ralph.sh sources exit.sh and sets up SIGINT trap
- Stuck detection triggers after 3 consecutive failures on same task
- Ctrl+C sets INTERRUPTED flag (checked at safe points)
- Critical sections (git commit) are protected from immediate interrupt
- All exit paths (COMPLETED, STUCK, ABORTED, INTERRUPTED) use exit_with_status
- Exit codes follow convention: 0=COMPLETED, 1=STUCK, 2=ABORTED, 3=INTERRUPTED
</success_criteria>

<output>
After completion, create `.planning/phases/05-exit-conditions/05-01-SUMMARY.md`
</output>
